// Define the `core.bidLog` module
var bidUtils = angular.module('core.bidUtils', []);

bidUtils.directive('ncgRequestVerificationToken', ['$http', function ($http) {
	return function (scope, element, attrs) {
		$http.defaults.headers.common['RequestVerificationToken'] = attrs.ncgRequestVerificationToken || "no request verification token";
	};
}]);

bidUtils.directive('runCtrlrFnWithThisElement', [
	function () {
		return {
			restrict: 'A',
			scope: {
				ctrlrFn: '&ctrlrFn',
				runCtrlrFnWithThisElement: '=?',
			},
			link: function (scope, element, attrs) {
				if (scope.runCtrlrFnWithThisElement) {
					var raw_element = element.get(0);
					scope.ctrlrFn({ raw_element: raw_element });
				}
			},
		}
	}
]);


var MyBIDAngularUtils = MyBIDAngularUtils || {};

MyBIDAngularUtils.helpers = {
	isObjectEmpty: function (card) {
		return Object.keys(card).length === 0;
	},
	compileAngularElement: function(elSelector) {
		var elSelector = (typeof elSelector == 'string') ? elSelector : null;
		// The new element to be added
		if (elSelector != null) {
			var $div = $(elSelector);

			// The parent of the new element
			var $target = $("[data-ng-app]");

			angular.element($target).injector().invoke(['$compile', function ($compile) {
				var $scope = angular.element($target).scope();
				$compile($div)($scope);
				// Finally, refresh the watch expressions in the new element
				$scope.$apply();
			}]);
		}
	}
};
angular.module('bidApp').requires.push('productToCustomer.services');

var productToCustomerServices = angular.module('productToCustomer.services', [
  'bidApp.services', 'ngCookies'
]);// Register `productList` component, along with its associated controller and template

var PRODUCTTOCUSTOMERCONSTANTS = PRODUCTTOCUSTOMERCONSTANTS || {};

productToCustomerServices.constant('productToCustomer.services.config', {
	ShowPriceRouteURL: PRODUCTTOCUSTOMERCONSTANTS.ShowPriceRouteURL,
	ShowImageRouteURL: PRODUCTTOCUSTOMERCONSTANTS.ShowImageRouteURL,
	ProductToCustomerCookieName: PRODUCTTOCUSTOMERCONSTANTS.ProductToCustomerCookieName,
	//ProductToCustomerCookieDaysTillExpires: '@Constant.Cookies.ProductToCustomer.DaysTillExpires',
	ProductToCustomerCookieTypes:  function () {
		var arr = (
			(PRODUCTTOCUSTOMERCONSTANTS.P2CTypesShowing.Wishlist ? 'Wishlist,' : '') +
			(PRODUCTTOCUSTOMERCONSTANTS.P2CTypesShowing.RecentlyViewed ? 'RecentlyViewed,' : '')
		)
		.split(',')
		.filter(function (el) { return el.length != 0 });
		var res = {};
		for (var i = 0; i < arr.length; i++)
			res[arr[i]] = {};
		return res;
	}()
});

productToCustomerServices.
  factory('ProductToCustomerService', ['$http', 'productToCustomer.services.config', '$q', '$cookies',
	function ($http, config, $q, $cookies) {
		//You can share the promise instead of sharing the data.[https://stackoverflow.com/questions/29940108/share-data-from-promise-with-callback-of-other-controller]
		var cachedProductToCustomerProducts = [];
		var parseProductToCustomerProducts = function (productToCustomer) { // <-- inner function
    		for (var i = 0; i < productToCustomer.length; i++) {
    			productToCustomer[i].displayPriceImageURL = config.ShowPriceRouteURL.replace("opx", productToCustomer[i].DisplayPriceWithCurrency);
    			productToCustomer[i].imageFullFileName = config.ShowImageRouteURL.replace("imagename", encodeURIComponent(productToCustomer[i].ImageFileName)) + "?v=" + productToCustomer[i].ImageFileVer + "&amp;width=125&amp;height=125&amp;switchoff=enabled";
    		};
    	};
    	var ProductToCustomerProductIdsToArray = function (productToCustomerProductIds) {
    		var data = [];
    		data.Success = true;
    		data.P2CList = productToCustomerProductIds.split(',').map(function (productID) {
    			return { ProductID : productID };
			});
			return data;
    	}
    	var ProductToCustomerProductArrayToIds = function (productToCustomerProductArray) {
			return productToCustomerProductArray.map(function (e) {
    			return e.ProductID;
    		}).join(',');
    	}
    	var cachedProductToCustomerProductsKey = function (prodToCustRelType, prodToCustRelReqType) {
    		return JSON.stringify({ ProductToCustomerRelationshipType: prodToCustRelType, ProductToCustomerRequestType: prodToCustRelReqType });
    	}
    	/*var SaveP2CReferenceToCookie = function (p2CRelationshipTypeName, p2CRelationshipGUID) {
    		//add item to cookie
    		var P2Ccookie = getMultiValues($cookies[config.ProductToCustomerCookieName]);

    		if (P2Ccookie == null) {
    			P2Ccookie = {};
    			P2Ccookie[config.ProductToCustomerCookieName] = null;
    		}

    		//Only write to cookie if no previous entry for this P2C Relationship type (or its different - eg returning from a merge with offline P2C list and existing P2C list associated with customer account)
    		if (P2Ccookie[p2CRelationshipTypeName] == null || P2Ccookie[p2CRelationshipTypeName] != p2CRelationshipGUID)
    		{
    			P2Ccookie[p2CRelationshipTypeName] = p2CRelationshipGUID;
    			var productToCustomerCookieValue = setMultiValuedCookie(config.ProductToCustomerCookieName, P2Ccookie, config.ProductToCustomerCookieDaysTillExpires);
    			//Start set cookie
    			var advanceTimeDays = config.ProductToCustomerCookieDaysTillExpires;
    			var date = null;
    			if (advanceTimeDays > 0) {
    				date = new Date();
    				var expireTime = date.getDate() + advanceTimeDays;
    				date.setTime(expireTime);
    			} // else null so we want session cookie
    			//console.log(date)
    			document.cookie = config.ProductToCustomerCookieName + productToCustomerCookieKey + '=' + productToCustomerCookieValue + ';path=/;' + (date == null ? '' : 'expires=' + date.toGMTString());
    			//End set cookie
    		}
    	};*/
    	/*var GetP2CReferenceFromCookie = function(p2CRelationshipTypeName)
		{
    		var P2Ccookie = getMultiValues($cookies[config.ProductToCustomerCookieName]);
    		var p2CRelationshipGUID = null;
    		if (P2Ccookie != null)
    		{
    			p2CRelationshipGUID = P2Ccookie.Values[p2CRelationshipTypeName];
    		}
    		return p2CRelationshipGUID;
		}*/
    	var setMultiValues = function (name, values, advanceTimeDays) {
    		var valuePairs = [];
    		for (var n in values) {
    			valuePairs.push(n + "=" + values[n]);
    		}
    		var cookieValue = valuePairs.join("&");
    		return cookieValue;
    	};
    	var getMultiValues = function (multiValues/*, value*/) {
    		var valuePairs = [];
    		if (typeof multiValues !== "undefined")
    			multiValues.split('&').map(function (originalValue) {
    				var name = originalValue.split('=')[0];
    				var value = originalValue.split('=')[1];
    				valuePairs[name] = value;
    			});
    		return valuePairs;
    	};
   		return {
   			SetP2CCookie: function (productToCustomerCookieName, productToCustomerCookieKey, p2CList) {
    			if(typeof productToCustomerCookieKey !== "undefined") {
    				var productToCustomerCookieValue = ProductToCustomerProductArrayToIds(p2CList);
    				document.cookie = productToCustomerCookieName + productToCustomerCookieKey + '=' + productToCustomerCookieValue + ';path=/;samesite=none;'; //expires=' + date.toGMTString();
   				}
    		},
    		ProductToCustomerProductsRequestTypeEnum: {
    			ProductToCustomerID: 0,
    			ProductToCustomerFill: 1
    		},
    		ProductToCustomerProductsData: config.ProductToCustomerCookieTypes/*[]*/,//initially we had empty array [] but now we want to add properties from various positions so now we prime it. With P2C types via the config
    		GetProductToCustomerProductsRequestTypeStatus: function (prodToCustRelType) {
    			return this.ProductToCustomerProductsData[prodToCustRelType].ProductToCustomerProductsRequestTypeStatus || ({ ProductToCustomerProductsRequestTypeStatus: this.ProductToCustomerProductsRequestTypeEnum.ProductToCustomerID/*Default uninitialised P2C array for the requested prodToCustRelType type to Ids only(unbloated with data)*/ }).ProductToCustomerProductsRequestTypeStatus;// || this.ProductToCustomerProductsRequestTypeEnum.ProductToCustomerID;
    		},
    		SetProductToCustomerProductsRequestTypeStatus: function (prodToCustRelType, prodToCustRelReqType) {
    			this.ProductToCustomerProductsData[prodToCustRelType].ProductToCustomerProductsRequestTypeStatus = prodToCustRelReqType;
    		},
    		AddProductToCustomerProduct: function (prodToCustRelType, prodid, data, exVATPrice, currency, vATRate) {
    			var prodToCustRelReqType = this.GetProductToCustomerProductsRequestTypeStatus(prodToCustRelType);//Get lazyloading status for productToCustomerRelationship
    			var prod = { ProductID: prodid, ExVATPrice: exVATPrice, Currency: currency, VATRate: vATRate, EarliestDelDate: data.Output_DeliveryDate };
    			var inputProdIds = { prodToCustRelType: prodToCustRelType, prodToCustRelReqType: prodToCustRelReqType, prodToCustRelItems: [prod] };
    			//return $http.post('/producttocustomer/AddToProductToCustomer', inputProdIds);
    			var that = this;
    			/*this.*/cachedProductToCustomerProducts[cachedProductToCustomerProductsKey(prodToCustRelType, prodToCustRelReqType)]/*this.cachedProductToCustomerProducts[prodToCustRelType]*/ =
                    $q(function (resolve, reject) {
                        $http.post('/producttocustomer/AddToProductToCustomer', inputProdIds)
                            .then(function (resp) {
                                if (prodToCustRelReqType == that.ProductToCustomerProductsRequestTypeEnum.ProductToCustomerFill)//If requesting full product data then explode the view model
                                    parseProductToCustomerProducts(resp.data.P2CList);
                                that.ProductToCustomerProductsData[prodToCustRelType].Data = resp.data;
                                resolve(resp.data/*'Success!'*/);
                                var productToCustomerCookieKey = resp.data.ProductToCustomerRelationshipGUID;//parseCookieToArray($cookies[config.ProductToCustomerCookieName])[prodToCustRelType];
                                //if (typeof productToCustomerCookieKey !== "undefined")
                                that.SetP2CCookie(config.ProductToCustomerCookieName, productToCustomerCookieKey, resp.data.P2CList);//Make this a public method cos also called by MVC Wishlist/RV Mobile view
                            }, function (resp) {
                                reject('Oops... something went wrong');
                                console.log(resp.statusText);
                            });
					});
    			return /*this.*/cachedProductToCustomerProducts[cachedProductToCustomerProductsKey(prodToCustRelType, prodToCustRelReqType)];
    		},
    		RemoveProductToCustomerProduct: function (prodToCustRelType, prodid) {
    			//var inputProdIds = { productIds: [prodid] };
    			//return $http.post('/producttocustomer/RemoveProductFromCustomer', inputProdIds);
    			var prodToCustRelReqType = this.GetProductToCustomerProductsRequestTypeStatus(prodToCustRelType);//Get lazyloading status for productToCustomerRelationship
    			var prod = { ProductID: prodid, ExVATPrice: 0, Currency: 'GBP', VATRate: 0, EarliestDelDate: new Date() };//Removing so fill rest of product with dummy data to fulfil validation(actual values dont matter)
    			var inputProdIds = { prodToCustRelType: prodToCustRelType, prodToCustRelReqType: prodToCustRelReqType, prodToCustRelItems: [prod] };
    			//return $http.post('/producttocustomer/AddToProductToCustomer', inputProdIds);
    			var that = this;
    			var prodToCustRelReqType = this.GetProductToCustomerProductsRequestTypeStatus(prodToCustRelType);//Get lazyloading status for productToCustomerRelationship
    			/*this.*/cachedProductToCustomerProducts[cachedProductToCustomerProductsKey(prodToCustRelType, prodToCustRelReqType)] =
                    $q(function (resolve, reject) {
                        $http.post('/producttocustomer/AddToProductToCustomer', inputProdIds)
                            .then(function (resp) {
                                if (prodToCustRelReqType == that.ProductToCustomerProductsRequestTypeEnum.ProductToCustomerFill)//If requesting full product data then explode the view model
                                    parseProductToCustomerProducts(resp.data.P2CList);
                                that.ProductToCustomerProductsData[prodToCustRelType].Data = resp.data;
                                resolve(resp.data/*'Success!'*/);
                                var productToCustomerCookieKey = resp.data.ProductToCustomerRelationshipGUID;//parseCookieToArray($cookies[config.ProductToCustomerCookieName])[prodToCustRelType];
                                //if (typeof productToCustomerCookieKey !== "undefined")
                                that.SetP2CCookie(config.ProductToCustomerCookieName, productToCustomerCookieKey, resp.data.P2CList);
                            }, function (resp) {
                                reject('Oops... something went wrong');
                                console.log(resp.statusText);
                            });
                    });
    			return /*this.*/cachedProductToCustomerProducts[cachedProductToCustomerProductsKey(prodToCustRelType, prodToCustRelReqType)];
    		},
    		//You can share the promise instead of sharing the data.[https://stackoverflow.com/questions/29940108/share-data-from-promise-with-callback-of-other-controller]
    		//cachedProductToCustomerProducts: [],
    		GetProductToCustomerProducts: function (prodToCustRelType/*, prodToCustRelReqType*/) {
    			var prodToCustRelReqType = this.GetProductToCustomerProductsRequestTypeStatus(prodToCustRelType);//Get lazyloading status for productToCustomerRelationship
    			/*function parseProductToCustomerProducts(productToCustomer) { // <-- inner function
    				for (var i = 0; i < productToCustomer.length; i++) {
    					productToCustomer[i].displayPriceImageURL = ShowPriceRouteURL.replace("opx", productToCustomer[i].DisplayPriceWithCurrency);
    					productToCustomer[i].imageFullFileName = ShowImageRouteURL.replace("imagename", encodeURIComponent(productToCustomer[i].ImageFileName)) + "?v=" + productToCustomer[i].ImageFileVer + "&amp;width=125&amp;height=125&amp;switchoff=enabled";
    				}
    			}*/
    			if (!/*this.*/cachedProductToCustomerProducts[cachedProductToCustomerProductsKey(prodToCustRelType, prodToCustRelReqType)]) {
    				var that = this;
    				/*this.*/cachedProductToCustomerProducts[cachedProductToCustomerProductsKey(prodToCustRelType, prodToCustRelReqType)] =
                        $q(function (resolve, reject) {
                            var productToCustomerCookieKey = getMultiValues($cookies.get(config.ProductToCustomerCookieName))[prodToCustRelType];
                            if (prodToCustRelReqType == that.ProductToCustomerProductsRequestTypeEnum.ProductToCustomerID)//if id request get from cookie first
                            {
                                if (productToCustomerCookieKey == "EMPTY") {
                                    resolve(new Array());
                                    return;//Even though promise resolved early - Due to "run to completion" I need to return also
                                }
                                var productToCustomerProductIds = $cookies.get(config.ProductToCustomerCookieName + productToCustomerCookieKey);
                                if (typeof productToCustomerProductIds !== "undefined") {
                                    var data = ProductToCustomerProductIdsToArray(productToCustomerProductIds);
                                    that.ProductToCustomerProductsData[prodToCustRelType/*, prodToCustRelReqType*/].Data = data;
                                    resolve(data);
                                    return;//Even though promise resolved early - Due to "run to completion" I need to return also
                                }
                            }
                            //console.log(parseCookieToArray($cookies[config.ProductToCustomerCookieName]));
                            //console.log(parseCookieToArray($cookies[config.ProductToCustomerCookieName])[prodToCustRelType]);
                            $http.post('/producttocustomer/GetProductToCustomerProducts', { prodToCustRelType: prodToCustRelType, prodToCustRelReqType: prodToCustRelReqType })
                                .then(function (resp) {
                                    if (prodToCustRelReqType == that.ProductToCustomerProductsRequestTypeEnum.ProductToCustomerFill)//If requesting full product data then explode the view model
                                        parseProductToCustomerProducts(resp.data.P2CList);
                                    that.ProductToCustomerProductsData[prodToCustRelType/*, prodToCustRelReqType*/].Data = resp.data;
                                    resolve(resp.data/*'Success!'*/);
                                    //if (typeof productToCustomerCookieKey !== "undefined")
                                    that.SetP2CCookie(config.ProductToCustomerCookieName, productToCustomerCookieKey, resp.data.P2CList);
                                    //$cookies[config.ProductToCustomerCookieName + productToCustomerCookieKey] = ProductToCustomerProductArrayToIds(data.P2CList);
                                }, function (resp) {
                                        reject('Oops... something went wrong');
                                        console.log(resp.statusText);
                                });
                        });
    			}
    			return /*this.*/cachedProductToCustomerProducts[cachedProductToCustomerProductsKey(prodToCustRelType, prodToCustRelReqType)];
    		},
    		/*GetProductToCustomerProducts: function (prodToCustRelType) {
    			if (!this.cachedProductToCustomerProducts[prodToCustRelType])
    				this.cachedProductToCustomerProducts[prodToCustRelType] = $http.post('/producttocustomer/GetProductToCustomerProducts', { prodToCustRelType: prodToCustRelType });
    			return this.cachedProductToCustomerProducts[prodToCustRelType];
    		},
    		ProductToCustomerProductsData: [],
    		GetProductToCustomerProductsData: function (prodToCustRelType) {
    			return this.ProductToCustomerProductsData[prodToCustRelType];
    		},
    		SetProductToCustomerProductsData: function (prodToCustRelType, productToCustomer) {
    			for (var i = 0; i < productToCustomer.length; i++) {
    				productToCustomer[i].displayPriceImageURL = ShowPriceRouteURL.replace("opx", productToCustomer[i].DisplayPriceWithCurrency);
    				productToCustomer[i].imageFullFileName = ShowImageRouteURL.replace("imagename", encodeURIComponent(productToCustomer[i].ImageFileName)) + "?v=" + productToCustomer[i].ImageFileVer + "&amp;width=125&amp;height=125&amp;switchoff=enabled";
    			}
    			this.ProductToCustomerProductsData[prodToCustRelType] = productToCustomer;
    		}*/
    		ClearCachedProductToCustomerProductsPromise: function (prodToCustRelType, prodToCustRelReqType) {
    			/*this.*/cachedProductToCustomerProducts[cachedProductToCustomerProductsKey(prodToCustRelType, prodToCustRelReqType)] = null;
   			}
    	};
    }
  ]);

angular.module('bidApp').requires.push('wishlist');

var wishlist = angular.module('wishlist', [
  /*'bidApp.services'*/'productToCustomer.services'
]);// Register `productList` component, along with its associated controller and template

angular.module('bidApp').requires.push('recentlyViewed');

var recentlyViewed = angular.module('recentlyViewed', [
  /*'bidApp.services', */'productToCustomer.services'
]);// Register `productList` component, along with its associated controller and template

var BIDAPPSERVICESCONSTANTS = BIDAPPSERVICESCONSTANTS || {};

bidAppServices.constant('bidAppServicesConstants', BIDAPPSERVICESCONSTANTS);

//angular.module('productAvailabilityService', []);
var fnProductAvailabilityService = function ($http, bidAppServicesConstants/*productAvailabilityHost, webAPIURL*/, $window, $q) {
	var fakeProductAvailability = function (isSuccessful, productid) {
		var deferred = $q.defer();
		var promise = deferred.promise;

		// success condition
		if (isSuccessful === true) {
			var text = '{ "data" : {' +
				'"productid":' + productid + ' , "stockmessage":"Not In Stock", "earliestdelivery":null, ' +
				'"huddersfieldmessage":null,"derbyshiremessage":null, ' +
				'"output_CutOffDateTime1":null, "Output_DeliveryDate": null' +
				'}}';

			deferred.resolve(JSON.parse(text));
			// error condition
		} else {
			deferred.reject('error');
		}

		promise.success = function (fn) {
			promise.then(fn);
			return promise;
		}

		promise.error = function (fn) {
			promise.then(null, fn);
			return promise;
		}

		return promise;
	};
	return {
		/*ProductAvailability: [],
		testReturn: null,
		GettestReturn: function() {
			if (!this.testReturn) {
				this.testReturn = 3;
			}
			return this.testReturn;
		},
		GetProductAvailability: function (productIDs, siteID) {
			var inputProdIds = JSON.stringify({ productids: productIDs, siteid: siteID })
			return $http.post(productAvailabilityHost + '/commoncontent/GetProductInfo.asmx/GetProductAvailabilityQuickByProductIDsSiteIDWithServerCache', inputProdIds);
		},
		SetProductAvailability: function (productAvailability) {
			this.ProductAvailability = productAvailability;
		},
		GetProductAvailabilitySingle: function (productID, siteID) {
			var inputProdId = {
				params: {
					productid: productID,
					siteid: siteID
				}
			}
			//var inputProdId = { productid: productID, siteid: siteID } // example of parameter being passed
			return $http.get(webAPIURL + '/api/ProductAvailability/GetProductAvailabilityByProductIDSiteIDWithServerCache', inputProdId);
		},*/
		//You can share the promise instead of sharing the data.[https://stackoverflow.com/questions/29940108/share-data-from-promise-with-callback-of-other-controller]
		cachedProductAvailability: []/*null Used to support a single call to it, now due to mini product view of bundles 03/08/20, supports array of calls keyed by productID*/, // assumes the ajax doesn't return a falsey value
		GetProductAvailabilitySingleCached: function (productID, siteID, productAvailable) {
			var inputProdId = {
				params: {
					productid: productID,
					siteid: siteID
				}
			}
			if (!this.cachedProductAvailability[productID])
				this.cachedProductAvailability[productID] = (productAvailable/*if product unavailable return fake availability(rather than make a http call when we dont need a real result)*/ ? $http.get(bidAppServicesConstants.webAPIURL + '/api/ProductAvailability/GetProductAvailabilityByProductIDSiteIDWithServerCache', inputProdId)/*actual request*/ : fakeProductAvailability(true, productID)/*fake request*/);
			return this.cachedProductAvailability[productID];
		},
		cachedProductAvailabilities: null,//[], // assumes the ajax doesn't return a falsey value
		/*SetProductAvailabilities: function (productAvailabilities) {
			this.cachedProductAvailabilities = productAvailabilities;
		},*/
		GetProductAvailabilities: function (productIDs, siteID) {
			//var productIDs = ["1224462", "1205911", "1198885", "1233987", "1240163", "1188008", "1213335", "1232851", "1220270", "1233988", "1220267", "1213330", "1195708", "1222258", "1171148", "1252250", "1186564", "1203737", "1203356", "1235733", "1213834", "1196846", "1175073", "1212010"];

			var inputProdIds = { /*productids: productIDs, */siteid: parseInt(siteID) }
			if (!this.cachedProductAvailabilities)
				this.cachedProductAvailabilities = $http.post(bidAppServicesConstants.webAPIURL + '/api/ProductAvailability/GetProductAvailabilityQuickByProductIDsSiteIDWithServerCache/?siteid=' + siteID, productIDs/*inputProdIds*/);
			return this.cachedProductAvailabilities;
		},
		productAvailabilities: [],
		/*ProductAvailabilitiesCount: function() {
			return $window.document.getElementsByClassName("OfferBoxPrice").length;
		}*/
	};
}

/*var bidAppServices = angular.
  module('bidApp.services')*/bidAppServices.//, []).//core.
  factory('ProductAvailabilityService', ['$http', 'bidAppServicesConstants'/*'productAvailabilityHost', 'webAPIURL'*/, '$window', '$q',
	fnProductAvailabilityService
//    function ($http, productAvailabilityHost, webAPIURL, $window, $q) {
//    	var fakeProductAvailability = function (isSuccessful) {
/*    		var deferred = $q.defer();
    		var promise = deferred.promise;

    		// success condition
    		if (isSuccessful === true) {
    			deferred.resolve('data');
    			// error condition
    		} else {
    			deferred.reject('error');
    		}

    		promise.success = function (fn) {
    			promise.then(fn);
    			return promise;
    		}

    		promise.error = function (fn) {
    			promise.then(null, fn);
    			return promise;
    		}

    		return promise;
    	};*/
//    	return {
    		/*ProductAvailability: [],
    		testReturn: null,
    		GettestReturn: function() {
    			if (!this.testReturn) {
    				this.testReturn = 3;
    			}
    			return this.testReturn;
    		},
    		GetProductAvailability: function (productIDs, siteID) {
    			var inputProdIds = JSON.stringify({ productids: productIDs, siteid: siteID })
    			return $http.post(productAvailabilityHost + '/commoncontent/GetProductInfo.asmx/GetProductAvailabilityQuickByProductIDsSiteIDWithServerCache', inputProdIds);
    		},
    		SetProductAvailability: function (productAvailability) {
    			this.ProductAvailability = productAvailability;
    		},
    		GetProductAvailabilitySingle: function (productID, siteID) {
    			var inputProdId = {
    				params: {
    					productid: productID,
    					siteid: siteID
    				}
    			}
    			//var inputProdId = { productid: productID, siteid: siteID } // example of parameter being passed
    			return $http.get(webAPIURL + '/api/ProductAvailability/GetProductAvailabilityByProductIDSiteIDWithServerCache', inputProdId);
    		},*/
    		//You can share the promise instead of sharing the data.[https://stackoverflow.com/questions/29940108/share-data-from-promise-with-callback-of-other-controller]
//    		cachedProductAvailability: null, // assumes the ajax doesn't return a falsey value
//    		GetProductAvailabilitySingleCached: function (productID, siteID, productAvailable) {
//    			var inputProdId = {
//    				params: {
//    					productid: productID,
//    					siteid: siteID
//    				}
//    			}
//    			if (!this.cachedProductAvailability)
//    				this.cachedProductAvailability = (productAvailable/*if product unavailable return fake availability(rather than make a http call when we dont need a real result)*/ ? $http.get(webAPIURL + '/api/ProductAvailability/GetProductAvailabilityByProductIDSiteIDWithServerCache', inputProdId)/*actual request*/ : fakeProductAvailability(true)/*fake request*/);
//    			return this.cachedProductAvailability;
//    		},
//    		cachedProductAvailabilities: null,//[], // assumes the ajax doesn't return a falsey value
    		/*SetProductAvailabilities: function (productAvailabilities) {
				this.cachedProductAvailabilities = productAvailabilities;
			},*/
//    		GetProductAvailabilities: function (productIDs, siteID) {
    			//var productIDs = ["1224462", "1205911", "1198885", "1233987", "1240163", "1188008", "1213335", "1232851", "1220270", "1233988", "1220267", "1213330", "1195708", "1222258", "1171148", "1252250", "1186564", "1203737", "1203356", "1235733", "1213834", "1196846", "1175073", "1212010"];

//    			var inputProdIds = { /*productids: productIDs, */siteid: parseInt(siteID) }
//    			if (!this.cachedProductAvailabilities)
//    				this.cachedProductAvailabilities = $http.post(webAPIURL + '/api/ProductAvailability/GetProductAvailabilityQuickByProductIDsSiteIDWithServerCache/?siteid=' + siteID, productIDs/*inputProdIds*/);
//    			return this.cachedProductAvailabilities;
//    		},
//    		productAvailabilities: [],
    		/*ProductAvailabilitiesCount: function() {
				return $window.document.getElementsByClassName("OfferBoxPrice").length;
			}*/
//    	};
//    }
  ]);

wishlist.directive('wishlistAmend', ['ProductToCustomerService', 'ProductAvailabilityService', '$window',
	function (ProductToCustomerService, ProductAvailabilityService, $window) {
		return {
			restrict: 'E',
			scope: {
				productID: '@productid',
				productAvailable: '=productavailable',
				siteID: '@siteid',
				exVATPrice: '@exvatprice',
				currency: '@currency',
				vATRate: '@vatrate',
				multipleMode: '='
			},
			replace: true,
			bindToController: true,
			controller: function ($scope) {
				//alert(ProductAvailabilityService.ProductAvailabilitiesCount());
				var wishlistAmendCtrl = this;

				wishlistAmendCtrl.IsInWishList = false;

				if (wishlistAmendCtrl.multipleMode)
					ProductAvailabilityService.productAvailabilities.push(wishlistAmendCtrl.productID);

				wishlistAmendCtrl.Add = wishlistAmendCtrl.multipleMode
				?
					function (/*productID, siteID, exVATPrice, currency, vATRate*/) {
						$window.ga('send', 'event', 'Wishlist', 'Added to Wishlist', 'Results Page'); //This would log a GA Event
						ProductAvailabilityService.GetProductAvailabilities(ProductAvailabilityService.productAvailabilities, wishlistAmendCtrl.siteID).resp(function (resp) {

							var single;
							for (var i = 0; i < resp.data.length; i++) {
								if (resp.data[i].productid == wishlistAmendCtrl.productID) {
									single = resp.data[i];
									break;
								}
							}

							AddToWishlist(wishlistAmendCtrl.productID, single, wishlistAmendCtrl.exVATPrice, wishlistAmendCtrl.currency, wishlistAmendCtrl.vATRate);
						}, function (resp) {
							console.log(resp.statusText);
						});
					}
				:
					function (/*productID, siteID, exVATPrice, currency, vATRate*/) {
						$window.ga('send', 'event', 'Wishlist', 'Added to Wishlist', 'Results Page'); //This would log a GA Event
						ProductAvailabilityService.GetProductAvailabilitySingleCached(wishlistAmendCtrl.productID, wishlistAmendCtrl.siteID, wishlistAmendCtrl.productAvailable).then(function (resp) {
							AddToWishlist(wishlistAmendCtrl.productID, resp.data, wishlistAmendCtrl.exVATPrice, wishlistAmendCtrl.currency, wishlistAmendCtrl.vATRate);
						}, function (resp) {
							console.log(resp.statusText);
						});
						/*WishlistService.Add(prod).success(function (data) {
							//WishlistService.RecallWishlist().push(prod);
							WishlistService.SetWishlist(WishlistService.RecallWishlist());
							//$scope.wishlist = data.Wishlist;
						});*/
					}
				;

				function AddToWishlist(productID, availability, exVATPrice, currency, vATRate) {
					ProductToCustomerService.AddProductToCustomerProduct('Wishlist', productID, availability, exVATPrice, currency, vATRate).then/*.success*/(function (data) {
						if (data.Success) {
							wishlistAmendCtrl.IsInWishList = !wishlistAmendCtrl.IsInWishList
							//ProductToCustomerService.SetProductToCustomerProductsData('Wishlist', data.P2CList);
						}
						else
							console.log('There was a problem adding to wishlist');
						//toastr['warning']('There was a problem when restoring the password.', '', { positionClass: "toast-top-center" });
					});
				}

				$scope.$watch(function () {
					return ProductToCustomerService.ProductToCustomerProductsData['Wishlist'].Data;//ProductToCustomerService.GetProductToCustomerProducts/*Data*/('Wishlist');
				},
				function (newVal, oldVal, scope) {
					if (newVal) {
						if (newVal.Success) {
							for (var i = 0; i < newVal.P2CList.length; i++) {
								if (newVal.P2CList[i].ProductID == wishlistAmendCtrl.productID) {
									wishlistAmendCtrl.IsInWishList = true;
									return;
								}
							}
						}
						wishlistAmendCtrl.IsInWishList = false;
					}
				});
				/*ProductToCustomerService.testNum++;
				console.log(ProductToCustomerService.testNum);*/

				//GetIsInWishlist();
				//function GetIsInWishlist() {
				ProductToCustomerService.GetProductToCustomerProducts('Wishlist');/*.then(function (data) {
					if (data.Success) {
						for (var i = 0; i < data.P2CList.length; i++) {
							if (data.P2CList[i].ProductID == wishlistAmendCtrl.productID) {
								wishlistAmendCtrl.IsInWishList = true;
								break;
							}
						}
					}
					wishlistAmendCtrl.IsInWishList = false;
				});*/
				//};
			},
			controllerAs: 'wishlistAmendCtrl',/*(wishlistAmendCtrl.IsIn() == true) ? \'addtowl\' : \'alreadyinwl\'wishlistAmendCtrl.productID, wishlistAmendCtrl.siteID, wishlistAmendCtrl.exVATPrice, wishlistAmendCtrl.currency, wishlistAmendCtrl.vATRate*/
			template: '<div class="showwl">\
                <a ng-class="(wishlistAmendCtrl.IsInWishList == true) ? \'alreadyinwl\' : \'addtowl\'" ng-click="wishlistAmendCtrl.Add()"><span>Add to wishlist</span></a>\
                <!--input id="wl_@product.ProductID" type="hidden" value="@product.ProductID _ @product.WebTitle _ @product.URL _ @Url.RouteUrl("ShowImage", new { filename = @product.PrimaryImage.FileName })?v=@product.PrimaryImage.Ver&amp;width=150&amp;height=150&amp;switchoff=enabled _ @WebHelper.ObfuscateString(Convert.ToInt32(product.ProductVolatileData.PriceDataStructured.Price.Display * 100).ToString()) _ @product.Discontinued.ToString().ToLower() _ @product.ProductVolatileData.PriceDataStructured.CCode"/-->\
                </div>'/*,
			templateUrl: '/customeraccount/OrderDetailTemplate'*/
		}
	}
]);
recentlyViewed.directive('recentlyViewedAmend', ['ProductToCustomerService', 'ProductAvailabilityService',
	function (ProductToCustomerService/*RecentlyViewedService*/, ProductAvailabilityService) {
		return {
			//should always be defined as an element
			restrict: 'E',
			scope: {
				productID: '@productid',
				productAvailable: '=productavailable',
				siteID: '@siteid',
				exVATPrice: '@exvatprice',
				currency: '@currency',
				vATRate: '@vatrate'
			},
			link: function (scope, element, attrs) {
                //alert(ProductAvailabilityService.GettestReturn());
                ProductAvailabilityService.GetProductAvailabilitySingleCached(scope.productID, scope.siteID, scope.productAvailable).then(function (resp) {
					ProductToCustomerService.AddProductToCustomerProduct('RecentlyViewed', scope.productID, resp.data, scope.exVATPrice, scope.currency, scope.vATRate).then/*.success*/(function (data) {
						if (data.Success) {
							//ProductToCustomerService.SetProductToCustomerProductsData('RecentlyViewed', data.P2CList)
						}
						else {
							console.log('There was a problem adding to recently viewed');
							//toastr['warning']('There was a problem when restoring the password.', '', { positionClass: "toast-top-center" });
						}
					});
				});
			}
		}
	}
])